除了瓶颈之外，这种架构也会导致一些组织问题。 假设公司正在发展并将采用需要 跨职能 小团队的敏捷开发方法。

解决微服务中的瓶颈问题：Micro Frontends 🎉

解决方案实际上非常明显，采用了多年来为后端服务工作的相同原则：将前端整体划分为小的UI片段。 但UI与服务并不十分相似，它是最终用户与产品之间的接口，应该是一致且无缝的。 更重要的是，在单页面应用时代，整个应用在客户端的浏览器上运行。 它们不再是简单的HTML文件，相反，它们是复杂的软件，达到了非常复杂的水平。 现在我觉得微型前端的定义是必要的：

Micro Frontends背后的想法是将网站或Web应用视为独立团队拥有的功能组合。 每个团队都有一个独特的业务或任务领域，做他们关注和专注的事情。团队是跨职能的，从数据库到用户界面开发端到端的功能

根据我迄今为止的经验，对于许多公司来说，直接采用上面提出的架构真的很难。 许多其他人都有巨大的遗留负担，这使他们无法迁移到新的架构。 出于这个原因，更柔软的中间解决方案更加灵活，易于采用和安全迁移至关重要。

为了更好地理解，我将每个小型单体应用称为微应用，因为它们都是独立的应用，而不仅仅是微服务，它们都有UI部件，每个都代表端到端的业务功能。

## 当我们拥有一个完全独立的独立微应用时，如何创建无缝且一致的UI体验？

好吧，这个问题没有灵丹妙药的答案，但其中一个想法是创建一个共享的UI库，它也是一个独立的微应用。 通过这种方式，所有其他微应用将依赖于共享的UI库微应用。 在这种情况下，我们刚刚创建了一个共享依赖项，我们就杀死了独立微应用的想法。

另一个想法是在根级共享CSS自定义变量（ CSS custom variables ）。 此解决方案的优势在于应用之间的全局可配置主题。

或者我们可以简单地在应用团队之间共享一些SASS变量和混合。 这种方法的缺点是UI元素的重复实现，并且应该对所有微应用始终检查和验证类似元素的设计的完整性。

## 我们如何确保一个团队不会覆盖另一个团队编写的CSS？

一种解决方案是通过CSS选择器名称进行CSS定义，这些名称由微应用名称精心选择。 通过将该范围任务放在拼接层上将减少开发开销，但会增加拼接层的责任。

另一种解决方案可以是强制每个微应用成为自定义Web组件（custom web component）。 这个解决方案的优点是浏览器完成了范围设计，但需要付出代价：使用shadow DOM进行服务器端渲染几乎是不可能的。 此外，自定义元素没有100％的浏览器支持，特别是IE。

## 我们应该如何在微应用之间共享全局信息？

这个问题指出了关于这个主题的最关注的问题之一，但解决方案非常简单：HTML 5具有相当强大的功能，大多数前端开发人员都不知道。 例如，自定义事件（custom events） 就是其中之一，它是在微应用中共享信息的解决方案。

或者，任何共享的pub-sub实现或T39可观察的实现都可以实现。 如果我们想要一个更复杂的全局状态处理程序，我们可以实现共享的微型Redux，通过这种方式我们可以实现更多的相应式架构。

## 如果所有微应用都是独立应用，我们如何进行客户端路由？

这个问题取决于设计的每个实现, 所有主要的现代框架都通过使用浏览器历史状态在客户端提供强大的路由机制, 问题在于哪个应用负责路由以及何时。

我目前的实用方法是创建一个共享客户端路由器，它只负责顶级路由，其余路由器属于相应的微应用。 假设我们有 /content/:id 路由定义。 共享路由器将解析 /content，已解析的路由将传递到ContentMicroApp。 ContentMicroApp是一个独立的服务器，它将仅使用 /:id 进行调用。

## 我们必须是服务器端渲染，但是有可能使用微前端吗？

服务器端呈现是一个棘手的问题。 如果你正在考虑iframes缝合微应用然后忘记服务器端渲染。 同样，拼接任务的Web组件也不比iframe强大。 但是，如果每个微应用能够在服务器端呈现其内容，那么拼接层将仅负责连接服务器端的HTML片段。

## 与传统环境集成至关重要！ 但是怎么样？

为了整合遗留系统，我想描述我自己的策略，我称之为“ 渐进式入侵 ”。

首先，我们必须实现拼接层，它应该具有透明代理的功能。 然后我们可以通过声明一个通配符路径将遗留系统定义为微应用：LegacyMicroApp 。 因此，所有流量都将到达拼接层，并将透明地代理到旧系统，因为我们还没有任何其他微应用。

下一步将是我们的 第一次逐步入侵 ：我们将从LegacyMicroApp中删除主要导航并用依赖项替换它。 这种依赖关系将是一个使用闪亮的新技术实现的微应用：NavigationMicroApp 。

## 如何编排客户端，这样我们每次都不需要重新加载页面？

客户端
编排
路由
隔离微应用
应用之间通信
微应用UI之间的一致性

服务端
服务端渲染
路由
依赖管理

它很容易从客户端开始，它有三个独立的主干结构：AppsManager， Loader， Router 和一个额外的MicroAppStore。

### AppsManager

AppsManager 是客户端微应用编排的核心。 AppsManager的主要功能是创建依赖关系树。 当解决了微应用的所有依赖关系时，它会实例化微应用。

### Loader

客户端微应用编排的另一个重要部分是Loader。 加载器的责任是从服务器端获取未解析的微应用。

### Router

为了解决客户端路由问题，我将 Router 引入了 microfe。 与常见的客户端路由器不同，microf 的功能有限，它不解析页面而是微应用。 假设我们有一个URL /content/detail/13 和一个ContentMicroApp。 在这种情况下，microfe 将URL解析为 /content/，它将调用ContentMicroApp /detail/13 URL部分。

### MicroAppStore

为了解决微应用到微应用客户端的通信，我将MicroAppStore引入了 microfe。 它具有与Redux库类似的功能，区别在于：它对异步数据结构更改和reducer 声明更灵活。

已经有一个框架叫做 single-spa。 该项目依赖于每个应用的命名约定来解析和加载微应用。 容易掌握想法并遵循模式。 因此，在您自己的本地环境中尝试该想法可能是一个很好的初步介绍。 但是项目的缺点是你必须以特定的方式构建每个微应用，以便他们可以很好地使用框架。

我正在大力尝试微前端，在我的脑海中有一个崇高的目标：创建一个微框架框架，可以解决大多数问题，而不会影响性能，易于开发和可测试性。 如果您有任何明智的想法，请不要犹豫，访问我的repo，打开问题或通过下面的评论或 Twitter DM 与我联系。 我会在那里帮助你！🙂